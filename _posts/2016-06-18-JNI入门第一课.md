---
layout: post
title:  "命令行JNI入门基础"
date:   2016-06-18 13:25:00 +0800
category: Java学习
tags: [Java, JNI, 命令行]
---

在《Mac下使用NetBeans学JNI》中介绍了如何设置NetBeans来进行Java和C的混合开发。IDE会简化我们的工作，但有些时候并没有IDE可用，只能依靠命令行进行开发。本文主要介绍在这种情况下怎样进行JNI开发。

> 假设已经安装好JDK。

### 创建Java类

使用熟悉的纯文本编辑器创建一个Java类`JNIDemo`，其中本地方法需要使用`native`关键字标识。个人一般喜欢使用Vim和Sublime Text。

```java
public class JNIDemo {
	public static void main(String[] args) {
		new JNIDemo().callNative();
	}
	//声明本地方法
	private native void callNative();
}
```

### 编译Java类

本地代码对应的头文件需要从**class**文件中生成，因此先编译访问了本地代码的Java类。

```shell
$ javac JNIDemo.java
$ ls
JNIDemo.class	JNIDemo.java
```

### 生成接口头文件

JDK提供了一个名为**javah**的工具可以从**class**中生成JNI所需要的头文件。

```shell
$ javah JNIDemo
$ ls
JNIDemo.class	JNIDemo.h	JNIDemo.java
```

**JNIDemo.h**的内容如下，定义了在Java源文件中使用的函数原型。

```c
/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
/* Header for class JNIDemo */

#ifndef _Included_JNIDemo
#define _Included_JNIDemo
#ifdef __cplusplus
extern "C" {
#endif
/*
 * Class:     JNIDemo
 * Method:    callNative
 * Signature: ()V
 */
JNIEXPORT void JNICALL Java_JNIDemo_callNative
  (JNIEnv *, jobject);

#ifdef __cplusplus
}
#endif
#endif
```

在头文件中只有一个名为`Java_JNIDemo_callNative`的函数。该名字由三部分组成：**Java**、类名和方法名。格式为**Java_{package_and_classname}_{function_name}(JNI arguments)**。函数参数分别为：

- `JNIEnv *`：引用JNI环境，通过该参数访问JNI的功能。
- `jobject`：Java的`this`对象。

### 实现本地函数

新建C语言源文件，实现头文件中声明的函数。

```c
#include "JNIDemo.h"
#include <stdio.h>

JNIEXPORT void JNICALL Java_JNIDemo_callNative
  (JNIEnv *env, jobject obj) 
{
	printf("This is a C function!\n");
}
```

### 编译本地代码

Java程序只能通过动态库加载本地代码，因此需要将C语言源码编译成动态库。Mac下的动态库一般是**dylib**或**jnilib**作为扩展名。编译的时候需要指定Java的JNI头文件路径。如果不是使用的系统自带JDK，需要先查询JDK安装路径。

```shell
$ java -version
java version "1.8.0_92"
Java(TM) SE Runtime Environment (build 1.8.0_92-b14)
Java HotSpot(TM) 64-Bit Server VM (build 25.92-b14, mixed mode)
```

系统里可以同时安装多个JDK，上面代码可以查看当前使用JDK的版本号。

```shell
$ /usr/libexec/java_home -v 1.8
/Library/Java/JavaVirtualMachines/jdk1.8.0_92.jdk/Contents/Home
```

**java_home**命令可以获取指定版本JDK的路径。JDK中包含的C语言头文件就处于该目录下。

```shell
$ clang -dynamiclib -I`/usr/libexec/java_home -v 1.8`/include -I`/usr/libexec/java_home -v 1.8`/include/darwin JNIDemo.c -o libJNIDemo.dylib
$ ls
JNIDemo.c			JNIDemo.java
JNIDemo.class		libJNIDemo.dylib
JNIDemo.h
```

> 需要使用`-dynamiclib`参数编译成动态库。并且动态库的名称格式为**lib+名称+.dylib**或**lib+名称+.jnilib**。
>
> 可以加上**-fPIC**优化加载速度。

### 修改Java代码，加载动态库

JVM默认不会加载刚才生成的动态库，因此需要在代码中通过调用函数加载。

```java
public class JNIDemo {
	static {
		//参数为动态库的名称（不包括lib和扩展名）
		System.loadLibrary("JNIDemo");
	}

	public static void main(String[] args) {
		new JNIDemo().callNative();
	}
	//声明本地方法
	private native void callNative();
}
```

修改完Java代码后需要重新使用**javac**编译。

> 可以使用`System.load()`加载动态库，不过参数为完整的动态库文件路径。

### 运行Java应用

使用**java**命令运行程序就会看到调用本地代码的结果。

```shell
$ java JNIDemo
This is a C function!
```

默认加载了当前目录下名为**libJNIDemo.dylib**或**libJNIDemo.jnilib**的动态库。